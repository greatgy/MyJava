#### 编码
	计算机上所有文件的储存是都是字节（byte）的储存
	8个比特（bit）作为一个字节（byte） ASCII处理字节
	ASCII无法处理中文，中国制定了GB2312将中文包含进去（GB2312只包含简体中文，GBK包含简体繁体等更多汉字）
	Unicode把所有语言都统一到一套编码里，通常是两个字节，但是文本都是英文的话会比ASCII多一倍的存储空间
	UTF-8 是可变长编码 表示英文用一个字节，表示汉字通常3个字节
	在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码
	用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件


#### 字节流和字符流
	字符流处理的单元为2个字节的Unicode字符，操作字符、字符数组、字符串
	字节流处理的单元为1个字节，操作字节或字节数组

	字节流直接操作文件本身，字符流操作使用缓冲区先将数据放入缓冲区再一次写入文件
	字节流操作文件即使不关闭资源文件也可以输出。字符流操作文件不关闭资源没有输出，说明了字符流使用了缓冲区，在不关闭资源的情况下可以使用flush强制刷新缓冲区输出内容

	类InputStreamReader和OutputStreamWriter处理字节流和字符流的转换
	

#### NIO
	NIO三个核心元素 channel、buffer、selector
	
	BIO是同步阻塞的，NIO是同步非阻塞的，io读写不阻塞
	BIO是基于流传输, NIO引入了channel buffer,基于buffer传输，只能从channel读取数据到buffer或从buffer写入数据到channel
	NIO使用单线程处理多个连接，通过selector轮询读写事件
	
	NIO使用IO多路复用
	select、poll都是轮询监听socket， 监听的socket有数量限制1024个，poll没有限制  epoll不是轮询，而是socket有数据时通过回调的方式主动通知用户进程
	优势在于能够处理多个连接而不是单个连接处理得更快
	

		当用户进程发起read系统调用时，如果内核缓冲区数据没有准备好，不会阻塞直接返回error信息，表现为非阻塞io，nio可以用一个线程处理多个连接，每次遍历socket数组判断是否可读 
		缺点是每次都要遍历所有连接，发出很多次系统调用 用户态内核态频繁切换
		由此产生了IO多路复用，java NIO中通过epoll方法实现 epoll返回就绪的连接fds

		select、poll 每次需要将fds拷贝到内核态 select有连接限制
		epoll内核态有一块内存存储fds,连接就绪会加入就绪列表，epoll返回就绪的连接fds，不用拷贝fds到内核态
	
	NIO中的零拷贝：MappedByteBuffer和transferTo()、transferFrom()两种方式
	MappedByteBuffer是通过mmap方式实现的
	transferTo、transferFrom通过sendfile方式实现
	区别是是否要对数据进行操作 还是仅仅数据传输
	
	
	阻塞IO 和 非阻塞IO 这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题：前者等待；后者继续执行（并且使用线程一直轮询，直到有IO资源准备好了）
	同步IO 和 非同步IO，这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何相应程序的问题：前者不响应，直到IO资源准备好以后；后者返回一个标记（好让程序和自己知道以后的数据往哪里通知），当IO资源准备好以后，再用事件机制返回给程序。

