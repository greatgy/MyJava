reids

	服务端有个redisServer对象
	redisServer中有redisDb对象数组（多少个库就多少个对象）
	redisDb对象中有一个字典保存所有的key-value对
	一个字典保存key-过期时间对
		
	过期键删除策略：定期删除+惰性删除
		定期删除：间隔一段时间查看设置了过期时间的键是否过期，淘汰
		惰性删除：查询时，先判断是否键过期，淘汰
		大量未即时查的过期数据使用内存淘汰机制  通常使用allkeys-lru删除最近最少使用的
		allkeys-lru在所有的key中删除最近最少使用的，volatile-lru在所有设置过期时间的key中删除最近最少使用的（内存满时，未过期也会删除）
		
	同时开启aof和rdb时，服务器崩溃重启后优先加载aof文件（aof写入频率高，丢失概率小）
	
redis基本数据类型

	string：普通的set和get，做简单的kv缓存
	hashmap:类似map的一种结构，可以将结构化的数据，比如一个对象缓存在redis  key=150 value={“id”: 150,“name”: “zhangsan”,“age”: 20}
	list:有序列表  key=某大v value=[zhangsan, lisi, wangwu]   （链表结构）
	set：去重集合
	sorted set:去重可根据score排序   （跳表结构）

	info memory查看redis内存   keys * 查看所有key

RDB持久化方式

	后台一个子进程通过bgsave命令，生成rdb文件
	服务端可以配置多个条件比如60 100这样时间段内发生多少次写入 触发bgsave
	多个配置是在redisServer对象中有个数组类型参数
	生成Rdb文件时过期键不会保存，服务器载入rdb文件时过期键也不会载入

AOF方式

	每个事件循环结束后都会将写入命令写入aof缓冲区
	根据配置决定什么时刻同步到文件
	always：每次事件循环结束都会同步到磁盘（fsync命令同步到磁盘）
	everysec：每隔1秒同步到磁盘（默认值）
	no：不会主动同步到磁盘，有系统自己决定

	aof文件过大达到配置的大小时，回台bgrewriteaof子线程触发重写aof
	重写期间发生的写入命令会保存到aof重写缓冲区，当重写完成后将缓冲区部分写入到写的aof文件，并且用新的文件替换旧的文件

		
缓存一致性问题
	
	1、先改数据库再删缓存 放到一个事务中 （修改数据库 未删缓存期间有部分读旧数据） （数据库修改成功，缓存修改失败 增加缓存修改重试，重试失败一定次数 保存到队列中 缓存恢复后修改）
	2、先删缓存 再改数据库 放到一个事务中 （等待1秒再删一次 等待是为了可能的并发read请求完成，写入脏数据）
        3、以上两种方式都会有一方失败情况，可以将要修改的值放在队列中 进行重试
	binlog同步法：通过cannal、kafka、rabbitmq等方式同步binlog到redis


##### 一主多从
	读写分离，多个从节点同步主节点数据

##### 哨兵机制
	为了防止主节点挂掉，导致无法处理写请求以及从节点无法同步数据

	引入哨兵（即特殊状态下的redis进程）来监控节点、选取新的主节点、以及通知从节点和客户端

	哨兵通过向redis节点发送ping命令来判断 节点是否存活，通过向主库发送info命令来获取所有的从节点信息

##### 哨兵集群

	单个哨兵实例容易引起主库下线误判，因此选择哨兵集群部署的方式，每个哨兵通过pub/sub方式订阅主库

	单个哨兵实例判断主库下线时为主观下线状态，n/2+1个实例判断主库下线后才可以判定主库为客观下线状态

	哨兵实例向其他哨兵实例发送主库主观下线状态请求同时会发送成为leader的请求，半数以上实例同意的实例成为leader

	在从库中选择一个主库，先看配置优先级，再看从库历史网络连接情况

	通过pub/sub模式通知从库及客户端完成主从切换
	
###### 缓存雪崩：

		大量key同一时间过期 （设置过期时间时加上随机数）
		redis服务不可用 （主从集群模式保证服务稳定）

###### 缓存击穿

		指的是 热点key过期 请求到达数据库（热点key不过期）

###### 缓存穿透

		指的是请求缓存和数据库都不存在的数据

		解决方案：缓存0值或缺省值
			布隆过滤器过滤掉不存在值的请求（会有误判，但是能过滤掉大部分）
